<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>HashMap 不考慮雜湊碰撞的情況下，取資料的時間複雜度為什麼是 O(1).md</title>
    <link href="/2024/12/15/HashMap-%E4%B8%8D%E8%80%83%E6%85%AE%E9%9B%9C%E6%B9%8A%E7%A2%B0%E6%92%9E%E7%9A%84%E6%83%85%E6%B3%81%E4%B8%8B%EF%BC%8C%E5%8F%96%E8%B3%87%E6%96%99%E7%9A%84%E6%99%82%E9%96%93%E8%A4%87%E9%9B%9C%E5%BA%A6%E7%82%BA%E4%BB%80%E9%BA%BC%E6%98%AF%20O(1)/"/>
    <url>/2024/12/15/HashMap-%E4%B8%8D%E8%80%83%E6%85%AE%E9%9B%9C%E6%B9%8A%E7%A2%B0%E6%92%9E%E7%9A%84%E6%83%85%E6%B3%81%E4%B8%8B%EF%BC%8C%E5%8F%96%E8%B3%87%E6%96%99%E7%9A%84%E6%99%82%E9%96%93%E8%A4%87%E9%9B%9C%E5%BA%A6%E7%82%BA%E4%BB%80%E9%BA%BC%E6%98%AF%20O(1)/</url>
    
    <content type="html"><![CDATA[<p>會查原因是因為在寫 MEXC 的題目時，看到了這題。</p><p>的確我知道 Map 在取值的時候是 O(1) 但我不知道是為什麼耶，還記得以前看到 Tree 知道取值至少是 O(log N)，啊現在告訴我是 O(1)，有點魔幻。</p><h1 id="Map-的底層結構"><a href="#Map-的底層結構" class="headerlink" title="Map 的底層結構"></a>Map 的底層結構</h1><p>先來看看 Map 的底層結構，我們所知的 Map 有幾個特性：</p><ol><li>無法插入重複的 key</li><li>key 在插入時會用 hash function 計算 hash code 來判斷是否重複</li></ol><p>來看看 java.util.HashMap <code>put()</code> 的這段，可以看到一開始初始化的底層是一個 Node&lt;K, V&gt; 陣列。</p><p><img src="/img/hash_map_structure_1.jpg"></p><p>java.util.HashMap</p><p>而計算出的 hash 則會被用在定位該元素在陣列內的位置。</p><p>這邊定位的方式是用<strong>位元運算</strong>處理的，為什麼這樣可以定位元素要放在陣列的哪個位置呢？</p><h1 id="為什麼用位元運算可以知道元素要放在陣列的哪個位置？有什麼好處？"><a href="#為什麼用位元運算可以知道元素要放在陣列的哪個位置？有什麼好處？" class="headerlink" title="為什麼用位元運算可以知道元素要放在陣列的哪個位置？有什麼好處？"></a>為什麼用位元運算可以知道元素要放在陣列的哪個位置？有什麼好處？</h1><p>位元運算 <strong>AND (&amp;)</strong> 代表什麼可以看這篇 ↓，簡而言之就是兩方都是 1 結果才是 1，其餘都是 0。</p><p><a href="https://yubin551.gitbook.io/java-note/basic_java_programming/operator/bitwise_operators">位元運算子 | Java備忘筆記</a></p><p>這邊採用這個方式，目的是要去除高位數字，讓最後的結果保持在陣列的長度內。舉個例子來說：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">hash: <span class="hljs-number">15</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span> hash <span class="hljs-keyword">function</span> 計算的結果<br>n: <span class="hljs-number">8</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 陣列長度<br></code></pre></td></tr></table></figure><table><thead><tr><th>數字</th><th>位元表示</th><th>數字</th><th>位元表示</th></tr></thead><tbody><tr><td>1</td><td>01</td><td>9</td><td>1001</td></tr><tr><td>2</td><td>10</td><td>10</td><td>1010</td></tr><tr><td>3</td><td>11</td><td>11</td><td>1011</td></tr><tr><td>4</td><td>100</td><td>12</td><td>1100</td></tr><tr><td>5</td><td>101</td><td>13</td><td>1101</td></tr><tr><td>6</td><td>110</td><td>14</td><td>1110</td></tr><tr><td>7</td><td>111</td><td>15</td><td>1111</td></tr><tr><td>8</td><td>1000</td><td>16</td><td>10000</td></tr></tbody></table><p>↓ 將這兩個數字轉換為 0 和 1 的位元表示</p><p><code>tab[(n -1) &amp; hash]</code> 帶入參數就是 <code>tab[7 &amp; 15]</code>，計算結果如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1111</span><br> <span class="hljs-number">111</span><br><span class="hljs-comment">----</span><br><span class="hljs-number">0111</span><br></code></pre></td></tr></table></figure><p>對應左邊的表就是 7，代表這個元素應該要放在索引 7。</p><p>上述的例子可能太過簡單，再舉個例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql">hash: <span class="hljs-number">67</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span> hash <span class="hljs-keyword">function</span> 計算的結果<br>n: <span class="hljs-number">18</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 陣列長度<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 將兩個數字轉換為 byte<br><span class="hljs-type">int</span> a <span class="hljs-operator">=</span> <span class="hljs-number">67</span>;<br><span class="hljs-type">int</span> b <span class="hljs-operator">=</span> <span class="hljs-number">18</span>;<br>System.out.println(&quot;a = &quot; <span class="hljs-operator">+</span> Integer.toBinaryString(a)); <span class="hljs-operator">/</span><span class="hljs-operator">/</span> a <span class="hljs-operator">=</span> <span class="hljs-number">1000011</span><br>System.out.println(&quot;b = &quot; <span class="hljs-operator">+</span> Integer.toBinaryString(b)); <span class="hljs-operator">/</span><span class="hljs-operator">/</span> b <span class="hljs-operator">=</span> <span class="hljs-number">10010</span><br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 計算結果<br><span class="hljs-number">1000011</span><br>  <span class="hljs-number">10010</span><br><span class="hljs-comment">--------</span><br><span class="hljs-number">0000010</span> <span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>代表該元素要放在陣列索引 5 的位置。</p><p>AND 運算之所以可以去除高位，主要依賴於其特性：『只有兩個都是 1 才是 1』，所以即使計算出來的 hash 再高，也為因為位數長度不同直接變成 0。</p><h1 id="什麼時候會發生碰撞（Collision）？"><a href="#什麼時候會發生碰撞（Collision）？" class="headerlink" title="什麼時候會發生碰撞（Collision）？"></a>什麼時候會發生碰撞（Collision）？</h1><p>雖然說 hash function 計算出來值相同的機率很低，但仍有可能發生。</p><p>也就是說當 hash 一樣， <code>tab[(n -1) &amp; hash]</code> 計算出來也會一樣，該位置已有元素就代表發生碰撞。</p><p>不過就算 hash 不相同，<code>tab[(n -1) &amp; hash]</code> 也有可能是相同值，都算是碰撞。</p><p>這時候 Map 會判斷 key 的 hash code 和存放 key 的 reference（即記憶體位址）是否相同。完全一樣的，就會將新的元素值覆蓋掉舊的。</p><p><img src="/img/hash_map_structure_2.png"></p><h1 id="什麼時候才會變成-Tree-的結構？"><a href="#什麼時候才會變成-Tree-的結構？" class="headerlink" title="什麼時候才會變成 Tree 的結構？"></a>什麼時候才會變成 Tree 的結構？</h1><ol><li>如果發生碰撞，且 key 的 hash 不相同</li><li>該位置的元素也不是 TreeNode</li></ol><p>基本上滿足這兩個條件，就有機會將該元素替換成 Tree 的結構。</p><p>不過在做這件事情的時候還會判斷以下的資訊：</p><ol><li>首先發生碰撞時，會先以 LinkedList 的結構連接指向下一個元素</li><li>不過當元素長度超過了 <code>TREEIFY_THRESHOLD</code>（預設是 8 個），那麼就會轉換成 Tree 的結構了（因為太長也會影響查詢的效能）。</li></ol><p>來看看這段的實作：</p><p><img src="/img/hash_map_structure_3.png"></p><ul><li>p 在上面已經宣告賦值為 <code>tab[(n-1) &amp; hash]</code>，代表拿到的 Map 內的元素</li><li>e 則是在這邊賦值 <code>p.next</code> 元素</li><li>在這邊會透過 <code>e = p.next</code> 不斷遍歷 LinkedList 並計算 binCount，當 binCount 超出 <code>TREEIFY_THRESHOLD</code> 就會將該節點替換成 Tree 的結構</li></ul><h1 id="那提到的-bucket-又是什麼？"><a href="#那提到的-bucket-又是什麼？" class="headerlink" title="那提到的 bucket 又是什麼？"></a>那提到的 bucket 又是什麼？</h1><p>雖然說 Map 的底層是陣列，不過元素會透過計算 hash 推算儲存的位置。</p><p>bucket 就是用來描述透過 hash 計算得出位置與元素的對應，描述該陣列中每個槽位的概念。</p><p>簡而言之，Map 的底層結構用 bucket 來描述，圖大概會像下面這樣。</p><p><img src="/img/hash_map_structure_4.jpg"></p><p>Bucket 內有可能是 LinkedList 結構也有可能是 Tree 的結構這樣。</p><p>至於 Collision 之後怎麼去處理 bucket 內的資料又是另一回事了。</p><p><a href="https://www.notion.so/Hash-Table-84c78ada8c1d4dcbb462ca83aef18011?pvs=21">Hash Table</a></p><h1 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h1><ul><li><a href="https://medium.com/@prinswu/time-complexity-of-hashmap-get-is-o-1-why-7b845390594">https://medium.com/@prinswu/time-complexity-of-hashmap-get-is-o-1-why-7b845390594</a></li><li><a href="https://yubin551.gitbook.io/java-note/basic_java_programming/operator/bitwise_operators">https://yubin551.gitbook.io/java-note/basic_java_programming/operator/bitwise_operators</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>Map</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Github Page 和 Hexo 主題建立部落格</title>
    <link href="/2024/06/15/%E4%BD%BF%E7%94%A8-Github-Page-%E5%92%8C-Hexo-%E4%B8%BB%E9%A1%8C%E5%BB%BA%E7%AB%8B%E9%83%A8%E8%90%BD%E6%A0%BC/"/>
    <url>/2024/06/15/%E4%BD%BF%E7%94%A8-Github-Page-%E5%92%8C-Hexo-%E4%B8%BB%E9%A1%8C%E5%BB%BA%E7%AB%8B%E9%83%A8%E8%90%BD%E6%A0%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="建立-Hexo-專案"><a href="#建立-Hexo-專案" class="headerlink" title="建立 Hexo 專案"></a>建立 Hexo 專案</h1><p>看<a href="https://chanchandev.com/note/Hexo/hexo-introduction/2335841689/">這篇</a>文章應該就非常夠用了!</p><ul><li><a href="https://github.com/hexojs/hexo">Hexo Github</a></li></ul><h1 id="挑選主題"><a href="#挑選主題" class="headerlink" title="挑選主題"></a>挑選主題</h1><p>在 <a href="https://hexo.io/themes/">Hexo Theme</a> 有提供非常多種的主題可以挑選，第一眼就相重這個有點小憂鬱又很療育的主題 <a href="https://github.com/fluid-dev/hexo-theme-fluid?tab=readme-ov-file">Fluid</a>。<br>尤其是畫面上打字機動畫的部分，超棒!</p><p><img src="/img/hexo_fluid_image.png"></p><p>官方本身就有很詳細的<a href="https://hexo.fluid-dev.com/docs/guide/">設定文件</a>可以參考，另外也有預設的 <a href="https://hexo.fluid-dev.com/docs/icon/#%E5%86%85%E7%BD%AE%E7%A4%BE%E4%BA%A4%E5%9B%BE%E6%A0%87">icons</a> 可以使用。</p><h1 id="Hexo-常用指令"><a href="#Hexo-常用指令" class="headerlink" title="Hexo 常用指令"></a>Hexo 常用指令</h1><blockquote><p>其他指令可以參考這:<a href="https://hexo.io/zh-cn/docs/commands">https://hexo.io/zh-cn/docs/commands</a></p></blockquote><h2 id="新增文章"><a href="#新增文章" class="headerlink" title="新增文章"></a>新增文章</h2><p>會新增一篇 markdown 文章在 <code>source</code> &gt; <code>_post</code> 資料夾底下。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">post</span> <span class="hljs-string">&quot;我的第一篇文章&quot;</span><br></code></pre></td></tr></table></figure><h2 id="本地啟動伺服器"><a href="#本地啟動伺服器" class="headerlink" title="本地啟動伺服器"></a>本地啟動伺服器</h2><p>在本機端啓動伺服器，預設是 <a href="http://localhost:4000/">http://localhost:4000/</a></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">hexo <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><h2 id="部署到-Github-上"><a href="#部署到-Github-上" class="headerlink" title="部署到 Github 上"></a>部署到 Github 上</h2><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">hexo clean <span class="hljs-meta">&amp;&amp; hexo deploy</span><br></code></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="圖片顯示問題"><a href="#圖片顯示問題" class="headerlink" title="圖片顯示問題"></a>圖片顯示問題</h2><p>參考: <a href="https://akoncc.github.io/2019/09/12/hexo-display-images/">https://akoncc.github.io/2019/09/12/hexo-display-images/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Github Page</tag>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

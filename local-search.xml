<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>TreeMap 是什麼？和 HashMap 的差別？</title>
    <link href="/2024/12/31/TreeMap-%E6%98%AF%E4%BB%80%E9%BA%BC%EF%BC%9F%E5%92%8C-HashMap-%E7%9A%84%E5%B7%AE%E5%88%A5%EF%BC%9F/"/>
    <url>/2024/12/31/TreeMap-%E6%98%AF%E4%BB%80%E9%BA%BC%EF%BC%9F%E5%92%8C-HashMap-%E7%9A%84%E5%B7%AE%E5%88%A5%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="TreeMap-的結構"><a href="#TreeMap-的結構" class="headerlink" title="TreeMap 的結構"></a>TreeMap 的結構</h1><p>在 Java 中，TreeMap 繼承和實作的對象比 HashMap 多，以下是他們之間的關係：</p><p><img src="/img/tree_map_1.png"></p><h2 id="建構式"><a href="#建構式" class="headerlink" title="建構式"></a>建構式</h2><p>先來看 TreeMap 的建構式。</p><p><img src="/img/tree_map_2.jpg"></p><p>可以看到成員變數 <code>comparator</code> 會隨傳入參數變化，沒有的話預設會是 null。</p><h2 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h2><p>由於 TreeMap 本身底層是一棵 Tree（紅黑樹），所以在放入元素時會先判斷跟節點是否存在。</p><p>在放入元素時都會拿 key 值比對，決定元素要放在哪。</p><p>不過這邊是根節點，所以在 <code>compare()</code> 中，是自己跟自己比較。</p><p><img src="/img/tree_map_3.jpg"></p><p>如果根節點存在呢？</p><p>那麼就會根據有沒有複寫 comparator 來執行比對，最終決定新的節點要放在紅黑樹的左邊還是右邊。</p><p>有沒有 comparator 的差別就在下方黃色框框的部分：</p><ul><li>沒有覆寫的用的是原本的 <code>compare()</code> 方法</li><li>有實作 Comparable 的則是使用 <code>compareTo()</code> 方法</li></ul><p><img src="/img/tree_map_4.jpg"></p><p>最後就是執行 add 的動作啦～</p><p><img src="/img/tree_map_5.jpg"></p><h1 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h1><p>由於是 Tree 的結構，所以搜尋時就使用二元搜尋，直到找到該元素對應的 key 的節點。</p><p>有沒有 <code>comparator</code> 的用途跟上面 <code>put()</code> 一樣，在於比較兩個 key 值決定往左邊子樹還是右邊子樹搜尋。</p><p>所以搜尋的複雜度會是 O(logN)。</p><p><img src="/img/tree_map_6.png"></p><h1 id="TreeMap-提供的額外方法"><a href="#TreeMap-提供的額外方法" class="headerlink" title="TreeMap 提供的額外方法"></a>TreeMap 提供的額外方法</h1><p>TreeMap 提供一些額外的方法，便於按範圍搜索或是按順序訪問存儲的鍵值對。</p><ul><li>firstKey</li><li>lastKey</li><li>headMap</li><li>tailMap</li></ul><p>以這個 TreeMap 的內容作為範例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">TreeMap&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br>map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;One&quot;</span>);<br>map.put(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;Three&quot;</span>);<br>map.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Two&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="firstKey"><a href="#firstKey" class="headerlink" title="firstKey()"></a><code>firstKey()</code></h2><blockquote><p>Returns the <em><strong>first (lowest)</strong></em> key currently in this map.</p><ul><li>這裡的 lowest 指的是 key 的排序順序中最小的值</li></ul></blockquote><p>回傳第一個（最小的） key。</p><p>如果 TreeMap 是空的，會拋出 NoSuchElementException。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> map.firstKey(); <span class="hljs-comment">// 返回 1</span><br></code></pre></td></tr></table></figure><h2 id="lastKey"><a href="#lastKey" class="headerlink" title="lastKey()"></a><code>lastKey()</code></h2><blockquote><p>Returns the last (highest) key currently in this map.</p><ul><li>這裡的 lowest 指的是 key 的排序順序中最大的值</li></ul></blockquote><p>TreeMap 中最大的鍵值。</p><p>同樣，如果 Map 是空的，會拋出 NoSuchElementException。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> map.lastKey(); <span class="hljs-comment">// 返回 3</span><br></code></pre></td></tr></table></figure><h2 id="headMap-K-toKey"><a href="#headMap-K-toKey" class="headerlink" title="headMap(K toKey)"></a><code>headMap(K toKey)</code></h2><blockquote><p>Returns a view of the portion of this map whose keys are <em><strong>strictly less</strong></em> than <code>toKey</code>. The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports.</p></blockquote><p>返回一個 view（型別是 <code>SortedMap&lt;K,V&gt;</code>，可以視為是一個子 Map），包含所有小於指定鍵值的項目。</p><ul><li>不包含指定的鍵值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 返回所有 key &lt; 2 的項目</span><br><span class="hljs-comment">// head 包含: &#123;1=&quot;One&quot;&#125;</span><br>SortedMap&lt;Integer, String&gt; head = map.headMap(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h2 id="tailMap-K-fromKey"><a href="#tailMap-K-fromKey" class="headerlink" title="tailMap(K fromKey)"></a><code>tailMap(K fromKey)</code></h2><blockquote><p>Returns a view of the portion of this map whose keys are <em><strong>greater than or equal to</strong></em> <code>fromKey</code>. The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports.</p></blockquote><p>返回一個 view（型別是 <code>SortedMap&lt;K,V&gt;</code>，可以視為是一個子 Map），包含所有大於或等於指定鍵值的項目。</p><ul><li>與 headMap() 不同，包含指定的鍵值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 返回所有 key &gt;= 2 的項目</span><br><span class="hljs-comment">// tail 包含: &#123;2=&quot;Two&quot;, 3=&quot;Three&quot;&#125;</span><br>SortedMap&lt;Integer, String&gt; tail = map.tailMap(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><hr><p>在使用上需要注意 headMap 和 tailMap 是原本 TreeMap 的映射，所以：</p><ul><li>對子 Map 的修改會反映到原始 Map</li><li>對原始 Map 的修改也會反映到子 Map</li><li>子 Map 仍然保持著原始 Map 的排序規則</li></ul><h1 id="整理"><a href="#整理" class="headerlink" title="整理"></a>整理</h1><table><thead><tr><th></th><th>HashMap</th><th>TreeMap</th></tr></thead><tbody><tr><td>底層實現</td><td>• 基於 Hash Table 實現，使用 Hash function 將 key 映射到 Bucket 中，以實現快速存儲和查找。</td><td>基於紅黑樹，是一種平衡二元搜索樹。</td></tr><tr><td>Big O</td><td>時間複雜度一般情況下為 O(1)，發生大量碰撞時最壞為 O(n)。</td><td>所有操作如插入、刪除、查找的時間複雜度都是 O(logN)。</td></tr><tr><td>排序＆順序</td><td>沒有排序，順序可能因爲插入、刪除等操作有所不同。</td><td>依照 key 做自然排序或根據指定的 Comparator 排序。</td></tr><tr><td>key 的特性</td><td>必須實現 <code>hashCode()</code> 和 <code>equals()</code> 方法，確保 hash table 正常運作。</td><td>key 必須實現 Comparable 介面，或是自訂 Comparator 以便進行排序。</td></tr></tbody></table><h1 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h1><ul><li><a href="https://blog.csdn.net/zhzjn/article/details/141688077?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~Ctr-2-141688077-blog-137589411.235%5Ev43%5Epc_blog_bottom_relevance_base5&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~Ctr-2-141688077-blog-137589411.235%5Ev43%5Epc_blog_bottom_relevance_base5&utm_relevant_index=5">https://blog.csdn.net/zhzjn/article/details/141688077?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7Ebaidujs_baidulandingword%7ECtr-2-141688077-blog-137589411.235%5Ev43%5Epc_blog_bottom_relevance_base5&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7Ebaidujs_baidulandingword%7ECtr-2-141688077-blog-137589411.235%5Ev43%5Epc_blog_bottom_relevance_base5&amp;utm_relevant_index=5</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/TreeMap.html#tailMap-K-">https://docs.oracle.com/javase/8/docs/api/java/util/TreeMap.html#tailMap-K-</a></li><li><a href="https://carger.tips/%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%A8%8E-java-map-%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AF%A6%E8%B8%90%E8%88%87%E6%87%89%E7%94%A8%E6%8A%80%E5%B7%A7">https://carger.tips/%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%A8%8E-java-map-%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AF%A6%E8%B8%90%E8%88%87%E6%87%89%E7%94%A8%E6%8A%80%E5%B7%A7</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>資料結構 Map</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>Map</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 的一些設定及用法</title>
    <link href="/2024/12/15/Hexo%20%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A8%AD%E5%AE%9A%E5%8F%8A%E7%94%A8%E6%B3%95/"/>
    <url>/2024/12/15/Hexo%20%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A8%AD%E5%AE%9A%E5%8F%8A%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="新增文章"><a href="#新增文章" class="headerlink" title="新增文章"></a>新增文章</h1><p>新增文章，通常用的 type 是 post。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">hexo <span class="hljs-keyword">new</span> [<span class="hljs-keyword">type</span>] [post_name]<br></code></pre></td></tr></table></figure><p>由於在 config 中有設定 title 後面的檔案類型是 markdown，所以在新增的時候不需要特別把檔名打出來。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># Writing</span><br><span class="hljs-attr">new_post_name:</span> <span class="hljs-string">:title.md</span> <span class="hljs-comment"># File name of new posts</span><br><span class="hljs-attr">default_layout:</span> <span class="hljs-string">post</span><br></code></pre></td></tr></table></figure><h1 id="Tags-頁面"><a href="#Tags-頁面" class="headerlink" title="Tags 頁面"></a>Tags 頁面</h1><p>由於不想要花時間編輯 tag 頁面，所以直接在 config 中設定 tag 頁面的內容。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">tag_dir:</span> tags<br></code></pre></td></tr></table></figure><ul><li>tags 是默認值，標籤頁面將會生成在網站的 <code>/tags/</code> 目錄下。</li><li>如果改成其他值，例如 <code>categories/tags</code>，標籤頁面將會生成在 <code>/categories/tags/</code> 目錄下。</li></ul><h1 id="Hexo-部署"><a href="#Hexo-部署" class="headerlink" title="Hexo 部署"></a>Hexo 部署</h1><p>啟動 hexo server 並重新部署。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo s -d</span><br></code></pre></td></tr></table></figure><p>部署 hexo 並推至 github。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo d -g</span><br></code></pre></td></tr></table></figure><h1 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h1><ul><li><a href="https://hexo.io/zh-tw/docs/variables">Hexo 參數</a></li><li><a href="https://ithelp.ithome.com.tw/articles/10208123?sc=pt">Hexo - 前端也能建置部落格！自訂變數篇</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap 不考慮雜湊碰撞的情況下，取資料的時間複雜度為什麼是 O(1).md</title>
    <link href="/2024/12/15/HashMap%20%E4%B8%8D%E8%80%83%E6%85%AE%E9%9B%9C%E6%B9%8A%E7%A2%B0%E6%92%9E%E7%9A%84%E6%83%85%E6%B3%81%E4%B8%8B%EF%BC%8C%E5%8F%96%E8%B3%87%E6%96%99%E7%9A%84%E6%99%82%E9%96%93%E8%A4%87%E9%9B%9C%E5%BA%A6%E7%82%BA%E4%BB%80%E9%BA%BC%E6%98%AF%20O(1)/"/>
    <url>/2024/12/15/HashMap%20%E4%B8%8D%E8%80%83%E6%85%AE%E9%9B%9C%E6%B9%8A%E7%A2%B0%E6%92%9E%E7%9A%84%E6%83%85%E6%B3%81%E4%B8%8B%EF%BC%8C%E5%8F%96%E8%B3%87%E6%96%99%E7%9A%84%E6%99%82%E9%96%93%E8%A4%87%E9%9B%9C%E5%BA%A6%E7%82%BA%E4%BB%80%E9%BA%BC%E6%98%AF%20O(1)/</url>
    
    <content type="html"><![CDATA[<p>會深入了解是因為在寫面試題目時，看到了這題。</p><p>的確我知道 Map 在取值的時候是 O(1) 但我不知道是為什麼耶，還記得以前看到 Tree 知道取值至少是 O(log N)，啊現在告訴我是 O(1)，有點魔幻。</p><h1 id="Map-的底層結構"><a href="#Map-的底層結構" class="headerlink" title="Map 的底層結構"></a>Map 的底層結構</h1><p>先來看看 Map 的底層結構，我們所知的 Map 有幾個特性：</p><ol><li>無法插入重複的 key</li><li>key 在插入時會用 hash function 計算 hash code 來判斷是否重複</li></ol><p>來看看 java.util.HashMap <code>put()</code> 的這段，可以看到一開始初始化的底層是一個 Node&lt;K, V&gt; 陣列。</p><p><img src="/img/hash_map_structure_1.jpg"></p><p>java.util.HashMap</p><p>而計算出的 hash 則會被用在定位該元素在陣列內的位置。</p><p>這邊定位的方式是用<strong>位元運算</strong>處理的，為什麼這樣可以定位元素要放在陣列的哪個位置呢？</p><h1 id="為什麼用位元運算可以知道元素要放在陣列的哪個位置？有什麼好處？"><a href="#為什麼用位元運算可以知道元素要放在陣列的哪個位置？有什麼好處？" class="headerlink" title="為什麼用位元運算可以知道元素要放在陣列的哪個位置？有什麼好處？"></a>為什麼用位元運算可以知道元素要放在陣列的哪個位置？有什麼好處？</h1><p>位元運算 <strong>AND (&amp;)</strong> 代表什麼可以看這篇 ↓，簡而言之就是兩方都是 1 結果才是 1，其餘都是 0。</p><p><a href="https://yubin551.gitbook.io/java-note/basic_java_programming/operator/bitwise_operators">位元運算子 | Java備忘筆記</a></p><p>這邊採用這個方式，目的是要去除高位數字，讓最後的結果保持在陣列的長度內。舉個例子來說：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">hash: 15 // hash function 計算的結果<br>n: 8 // 陣列長度<br></code></pre></td></tr></table></figure><table><thead><tr><th>數字</th><th>位元表示</th><th>數字</th><th>位元表示</th></tr></thead><tbody><tr><td>1</td><td>01</td><td>9</td><td>1001</td></tr><tr><td>2</td><td>10</td><td>10</td><td>1010</td></tr><tr><td>3</td><td>11</td><td>11</td><td>1011</td></tr><tr><td>4</td><td>100</td><td>12</td><td>1100</td></tr><tr><td>5</td><td>101</td><td>13</td><td>1101</td></tr><tr><td>6</td><td>110</td><td>14</td><td>1110</td></tr><tr><td>7</td><td>111</td><td>15</td><td>1111</td></tr><tr><td>8</td><td>1000</td><td>16</td><td>10000</td></tr></tbody></table><p>↓ 將這兩個數字轉換為 0 和 1 的位元表示</p><p><code>tab[(n -1) &amp; hash]</code> 帶入參數就是 <code>tab[7 &amp; 15]</code>，計算結果如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">1111<br> 111<br>----<br>0111<br></code></pre></td></tr></table></figure><p>對應左邊的表就是 7，代表這個元素應該要放在索引 7。</p><p>上述的例子可能太過簡單，再舉個例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">hash: <span class="hljs-number">67</span> <span class="hljs-comment">// hash function 計算的結果</span><br>n: <span class="hljs-number">18</span> <span class="hljs-comment">// 陣列長度</span><br><br><span class="hljs-comment">// 將兩個數字轉換為 byte</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">67</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">18</span>;<br>System.out.println(<span class="hljs-string">&quot;a = &quot;</span> + Integer.toBinaryString(a)); <span class="hljs-comment">// a = 1000011</span><br>System.out.println(<span class="hljs-string">&quot;b = &quot;</span> + Integer.toBinaryString(b)); <span class="hljs-comment">// b = 10010</span><br><br><span class="hljs-comment">// 計算結果</span><br><span class="hljs-number">1000011</span><br>  <span class="hljs-number">10010</span><br>--------<br><span class="hljs-number">0000010</span> =&gt; <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>代表該元素要放在陣列索引 5 的位置。</p><p>AND 運算之所以可以去除高位，主要依賴於其特性：『只有兩個都是 1 才是 1』，所以即使計算出來的 hash 再高，也為因為位數長度不同直接變成 0。</p><h1 id="什麼時候會發生碰撞（Collision）？"><a href="#什麼時候會發生碰撞（Collision）？" class="headerlink" title="什麼時候會發生碰撞（Collision）？"></a>什麼時候會發生碰撞（Collision）？</h1><p>雖然說 hash function 計算出來值相同的機率很低，但仍有可能發生。</p><p>也就是說當 hash 一樣， <code>tab[(n -1) &amp; hash]</code> 計算出來也會一樣，該位置已有元素就代表發生碰撞。</p><p>不過就算 hash 不相同，<code>tab[(n -1) &amp; hash]</code> 也有可能是相同值，都算是碰撞。</p><p>這時候 Map 會判斷 key 的 hash code 和存放 key 的 reference（即記憶體位址）是否相同。完全一樣的，就會將新的元素值覆蓋掉舊的。</p><p><img src="/img/hash_map_structure_2.png"></p><h1 id="什麼時候才會變成-Tree-的結構？"><a href="#什麼時候才會變成-Tree-的結構？" class="headerlink" title="什麼時候才會變成 Tree 的結構？"></a>什麼時候才會變成 Tree 的結構？</h1><ol><li>如果發生碰撞，且 key 的 hash 不相同</li><li>該位置的元素也不是 TreeNode</li></ol><p>基本上滿足這兩個條件，就有機會將該元素替換成 Tree 的結構。</p><p>不過在做這件事情的時候還會判斷以下的資訊：</p><ol><li>首先發生碰撞時，會先以 LinkedList 的結構連接指向下一個元素</li><li>不過當元素長度超過了 <code>TREEIFY_THRESHOLD</code>（預設是 8 個），那麼就會轉換成 Tree 的結構了（因為太長也會影響查詢的效能）。</li></ol><p>來看看這段的實作：</p><p><img src="/img/hash_map_structure_3.png"></p><ul><li>p 在上面已經宣告賦值為 <code>tab[(n-1) &amp; hash]</code>，代表拿到的 Map 內的元素</li><li>e 則是在這邊賦值 <code>p.next</code> 元素</li><li>在這邊會透過 <code>e = p.next</code> 不斷遍歷 LinkedList 並計算 binCount，當 binCount 超出 <code>TREEIFY_THRESHOLD</code> 就會將該節點替換成 Tree 的結構</li></ul><h1 id="那提到的-bucket-又是什麼？"><a href="#那提到的-bucket-又是什麼？" class="headerlink" title="那提到的 bucket 又是什麼？"></a>那提到的 bucket 又是什麼？</h1><p>雖然說 Map 的底層是陣列，不過元素會透過計算 hash 推算儲存的位置。</p><p>bucket 就是用來描述透過 hash 計算得出位置與元素的對應，描述該陣列中每個槽位的概念。</p><p>簡而言之，Map 的底層結構用 bucket 來描述，圖大概會像下面這樣。</p><p><img src="/img/hash_map_structure_4.jpg"></p><p>Bucket 內有可能是 LinkedList 結構也有可能是 Tree 的結構這樣。</p><p>至於 Collision 之後怎麼去處理 bucket 內的資料又是另一回事了。</p><p><a href="https://www.notion.so/Hash-Table-84c78ada8c1d4dcbb462ca83aef18011?pvs=21">Hash Table</a></p><h1 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h1><ul><li><a href="https://medium.com/@prinswu/time-complexity-of-hashmap-get-is-o-1-why-7b845390594">https://medium.com/@prinswu/time-complexity-of-hashmap-get-is-o-1-why-7b845390594</a></li><li><a href="https://yubin551.gitbook.io/java-note/basic_java_programming/operator/bitwise_operators">https://yubin551.gitbook.io/java-note/basic_java_programming/operator/bitwise_operators</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>資料結構 Map</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>Map</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Github Page 和 Hexo 主題建立部落格</title>
    <link href="/2024/06/15/%E4%BD%BF%E7%94%A8-Github-Page-%E5%92%8C-Hexo-%E4%B8%BB%E9%A1%8C%E5%BB%BA%E7%AB%8B%E9%83%A8%E8%90%BD%E6%A0%BC/"/>
    <url>/2024/06/15/%E4%BD%BF%E7%94%A8-Github-Page-%E5%92%8C-Hexo-%E4%B8%BB%E9%A1%8C%E5%BB%BA%E7%AB%8B%E9%83%A8%E8%90%BD%E6%A0%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="建立-Hexo-專案"><a href="#建立-Hexo-專案" class="headerlink" title="建立 Hexo 專案"></a>建立 Hexo 專案</h1><p>看<a href="https://chanchandev.com/note/Hexo/hexo-introduction/2335841689/">這篇</a>文章應該就非常夠用了!</p><ul><li><a href="https://github.com/hexojs/hexo">Hexo Github</a></li></ul><h1 id="挑選主題"><a href="#挑選主題" class="headerlink" title="挑選主題"></a>挑選主題</h1><p>在 <a href="https://hexo.io/themes/">Hexo Theme</a> 有提供非常多種的主題可以挑選，第一眼就相重這個有點小憂鬱又很療育的主題 <a href="https://github.com/fluid-dev/hexo-theme-fluid?tab=readme-ov-file">Fluid</a>。<br>尤其是畫面上打字機動畫的部分，超棒!</p><p><img src="/img/hexo_fluid_image.png"></p><p>官方本身就有很詳細的<a href="https://hexo.fluid-dev.com/docs/guide/">設定文件</a>可以參考，另外也有預設的 <a href="https://hexo.fluid-dev.com/docs/icon/#%E5%86%85%E7%BD%AE%E7%A4%BE%E4%BA%A4%E5%9B%BE%E6%A0%87">icons</a> 可以使用。</p><h1 id="Hexo-常用指令"><a href="#Hexo-常用指令" class="headerlink" title="Hexo 常用指令"></a>Hexo 常用指令</h1><blockquote><p>其他指令可以參考這:<a href="https://hexo.io/zh-cn/docs/commands">https://hexo.io/zh-cn/docs/commands</a></p></blockquote><h2 id="新增文章"><a href="#新增文章" class="headerlink" title="新增文章"></a>新增文章</h2><p>會新增一篇 markdown 文章在 <code>source</code> &gt; <code>_post</code> 資料夾底下。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">post</span> <span class="hljs-string">&quot;我的第一篇文章&quot;</span><br></code></pre></td></tr></table></figure><h2 id="本地啟動伺服器"><a href="#本地啟動伺服器" class="headerlink" title="本地啟動伺服器"></a>本地啟動伺服器</h2><p>在本機端啓動伺服器，預設是 <a href="http://localhost:4000/">http://localhost:4000/</a></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">hexo <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><h2 id="部署到-Github-上"><a href="#部署到-Github-上" class="headerlink" title="部署到 Github 上"></a>部署到 Github 上</h2><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">hexo clean <span class="hljs-meta">&amp;&amp; hexo deploy</span><br></code></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="圖片顯示問題"><a href="#圖片顯示問題" class="headerlink" title="圖片顯示問題"></a>圖片顯示問題</h2><p>參考: <a href="https://akoncc.github.io/2019/09/12/hexo-display-images/">https://akoncc.github.io/2019/09/12/hexo-display-images/</a></p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Github Page</tag>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
